        -:    0:Source:uuid_v1_ops.c
        -:    0:Graph:uuid_v1_ops.gcno
        -:    0:Data:uuid_v1_ops.gcda
        -:    0:Runs:2
        -:    1:#include <uuid_v1_ops.h>
        -:    2:
        -:    3:Datum
        4:    4:is_uuid_v1(PG_FUNCTION_ARGS)
        -:    5:{
        4:    6:	pg_uuid_t  *arg1 = PG_GETARG_UUID_P(0);
        -:    7:
        4:    8:	PG_RETURN_BOOL(
        -:    9:				   (arg1->data[UUID_VERSION_OFFSET] & 0xf0) == 0x10
        -:   10:		);
        -:   11:}
        -:   12:
        -:   13:static int64
   257458:   14:uuid_v1_get_timestamp_internal(pg_uuid_t *uuid)
        -:   15:{
        -:   16:	uint64		res;			/* number of 100ns intervals since EPOCH */
        -:   17:
   257458:   18:	res = ((uint64) ((uuid->data[order[0]]) & 0x0F)) << 56;
  2059664:   19:	for (int i = 1; i < UUID_V1_TIMESTAMP_LEN; ++i)
        -:   20:	{
        -:   21:		/* this conversion is safe regardless of the endiannes */
  1802206:   22:		res += ((uint64) uuid->data[order[i]]) << ((UUID_V1_TIMESTAMP_LEN - i - 1) * 8);
        -:   23:	}
        -:   24:
   257458:   25:	return res;
        -:   26:}
        -:   27:
        -:   28:Datum
     1448:   29:uuid_v1_get_timestamptz(PG_FUNCTION_ARGS)
        -:   30:{
     1448:   31:	pg_uuid_t  *arg1 = PG_GETARG_UUID_P(0);
        -:   32:	uint64		res;
        -:   33:	uint64		gns;			/* number of 100ns intervals since EPOCH */
        -:   34:
     1448:   35:	gns = uuid_v1_get_timestamp_internal(arg1);
     1448:   36:	res = (gns / UUID_V1_100NS_TO_USEC) - GREGORIAN_BEGINNING_OFFSET_USEC;
     1448:   37:	PG_RETURN_TIMESTAMPTZ(res);
        -:   38:}
        -:   39:
        -:   40:Datum
   256010:   41:uuid_v1_get_timestamp_as_int8(PG_FUNCTION_ARGS)
        -:   42:{
   256010:   43:	pg_uuid_t  *arg1 = PG_GETARG_UUID_P(0);
        -:   44:
   256010:   45:	PG_RETURN_INT64(uuid_v1_get_timestamp_internal(arg1));
        -:   46:}
        -:   47:
        -:   48:
        -:   49:Datum
   256984:   50:uuid_v1_cmp(PG_FUNCTION_ARGS)
        -:   51:{
   256984:   52:	pg_uuid_t  *arg1 = PG_GETARG_UUID_P(0);
   256984:   53:	pg_uuid_t  *arg2 = PG_GETARG_UUID_P(1);
        -:   54:
   256984:   55:	PG_RETURN_INT32(uuid_v1_internal_cmp(arg1, arg2));
        -:   56:}
        -:   57:
        -:   58:static int
   256992:   59:uuid_v1_internal_cmp(const pg_uuid_t *arg1, const pg_uuid_t *arg2)
        -:   60:{
        -:   61:	int			res;
        -:   62:
  2054896:   63:	for (int i = 0; i < UUID_LEN; ++i)
        -:   64:	{
  2054892:   65:		res = arg1->data[order[i]] - arg2->data[order[i]];
  2054892:   66:		if (res != 0)
   256988:   67:			break;
        -:   68:	}
        -:   69:
   256992:   70:	return res;
        -:   71:}
        -:   72:
        -:   73:Datum
        2:   74:uuid_v1_lt(PG_FUNCTION_ARGS)
        -:   75:{
        2:   76:	pg_uuid_t  *arg1 = PG_GETARG_UUID_P(0);
        2:   77:	pg_uuid_t  *arg2 = PG_GETARG_UUID_P(1);
        -:   78:
       2*:   79:	PG_RETURN_BOOL(uuid_v1_internal_cmp(arg1, arg2) < 0);
        -:   80:}
        -:   81:
        -:   82:Datum
        2:   83:uuid_v1_le(PG_FUNCTION_ARGS)
        -:   84:{
        2:   85:	pg_uuid_t  *arg1 = PG_GETARG_UUID_P(0);
        2:   86:	pg_uuid_t  *arg2 = PG_GETARG_UUID_P(1);
        -:   87:
       2*:   88:	PG_RETURN_BOOL(uuid_v1_internal_cmp(arg1, arg2) <= 0);
        -:   89:}
        -:   90:
        -:   91:Datum
        2:   92:uuid_v1_ge(PG_FUNCTION_ARGS)
        -:   93:{
        2:   94:	pg_uuid_t  *arg1 = PG_GETARG_UUID_P(0);
        2:   95:	pg_uuid_t  *arg2 = PG_GETARG_UUID_P(1);
        -:   96:
       2*:   97:	PG_RETURN_BOOL(uuid_v1_internal_cmp(arg1, arg2) >= 0);
        -:   98:}
        -:   99:
        -:  100:Datum
        2:  101:uuid_v1_gt(PG_FUNCTION_ARGS)
        -:  102:{
        2:  103:	pg_uuid_t  *arg1 = PG_GETARG_UUID_P(0);
        2:  104:	pg_uuid_t  *arg2 = PG_GETARG_UUID_P(1);
        -:  105:
       2*:  106:	PG_RETURN_BOOL(uuid_v1_internal_cmp(arg1, arg2) > 0);
        -:  107:}
        -:  108:
        -:  109:Datum
     1452:  110:uuid_v1_get_node_id(PG_FUNCTION_ARGS)
        -:  111:{
     1452:  112:	pg_uuid_t  *arg1 = PG_GETARG_UUID_P(0);
        -:  113:	macaddr    *result;
        -:  114:
     1452:  115:	result = (macaddr *) palloc(sizeof(macaddr));
        -:  116:
     1452:  117:	result->a = arg1->data[UUID_V1_NODE_OFFSET_A];
     1452:  118:	result->b = arg1->data[UUID_V1_NODE_OFFSET_B];
     1452:  119:	result->c = arg1->data[UUID_V1_NODE_OFFSET_C];
     1452:  120:	result->d = arg1->data[UUID_V1_NODE_OFFSET_D];
     1452:  121:	result->e = arg1->data[UUID_V1_NODE_OFFSET_E];
     1452:  122:	result->f = arg1->data[UUID_V1_NODE_OFFSET_F];
        -:  123:
     1452:  124:	PG_RETURN_MACADDR_P(result);
        -:  125:}
        -:  126:
        -:  127:Datum
     1452:  128:uuid_v1_get_clock_seq(PG_FUNCTION_ARGS)
        -:  129:{
     1452:  130:	pg_uuid_t  *arg1 = PG_GETARG_UUID_P(0);
        -:  131:	int16		seq;
        -:  132:
     1452:  133:	seq = ((int16) ((arg1->data[UUID_V1_SEQ_OFFSET]) & 0x3F)) << 8;
     1452:  134:	seq += arg1->data[UUID_V1_SEQ_OFFSET + 1];
        -:  135:
     1452:  136:	PG_RETURN_INT16(seq);
        -:  137:}
        -:  138:
        -:  139:Datum
        8:  140:uuid_v1_get_variant(PG_FUNCTION_ARGS)
        -:  141:{
        8:  142:	pg_uuid_t  *arg1 = PG_GETARG_UUID_P(0);
        -:  143:	int16		v;
        -:  144:
        8:  145:	v = ((int16) ((arg1->data[UUID_V1_SEQ_OFFSET]) & 0xC0)) >> 6;
        -:  146:
        8:  147:	PG_RETURN_INT16(v);
        -:  148:}
        -:  149:
        -:  150:Datum
     2886:  151:uuid_v1_create_from_ts(PG_FUNCTION_ARGS)
        -:  152:{
     2886:  153:	TimestampTz ts = PG_GETARG_TIMESTAMPTZ(0);
     2886:  154:	int16		clock_seq = PG_GETARG_INT16(1);
     2886:  155:	macaddr    *node = PG_GETARG_MACADDR_P(2);
        -:  156:
        -:  157:	/*
        -:  158:	 * Convert PostgreSQL epoch usec timestamptz to the UUID v1 Gregorian
        -:  159:	 * epoch 0.1usec This can overflow, so we need to be careful. UUID v1
        -:  160:	 * Timestamp is unsigned and thus can't represent dates before it's epoch.
        -:  161:	 */
        -:  162:
     2886:  163:	if (unlikely((ts > UUID_V1_GREATEST_SUPPORTED_TIMESTAMP ||
        -:  164:				  ts < UUID_V1_LEAST_SUPPORTED_TIMESTAMP)))
        -:  165:	{
       2*:  166:		ereport(ERROR,
        -:  167:				(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),
        -:  168:				 errmsg("timestamp value out of range for UUID v1")));
        -:  169:	}
        -:  170:
     2884:  171:	ts = (ts + GREGORIAN_BEGINNING_OFFSET_USEC) * UUID_V1_100NS_TO_USEC;
        -:  172:
     2884:  173:	PG_RETURN_UUID_P(uuid_v1_create_from_internal(ts, clock_seq, node));
        -:  174:}
        -:  175:
        -:  176:Datum
   256006:  177:uuid_v1_create_from_int8(PG_FUNCTION_ARGS)
        -:  178:{
   256006:  179:	int64		ts = PG_GETARG_INT64(0);
   256006:  180:	int16		clock_seq = PG_GETARG_INT16(1);
   256006:  181:	macaddr    *node = PG_GETARG_MACADDR_P(2);
        -:  182:
   256006:  183:	if (unlikely((ts & UUID_V1_GREATEST_SUPPORTED_INT8) != 0))
        -:  184:	{
       2*:  185:		ereport(ERROR,
        -:  186:				(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),
        -:  187:				 errmsg("timestamp value out of range for UUID v1")));
        -:  188:	}
        -:  189:
        -:  190:
   256004:  191:	PG_RETURN_UUID_P(uuid_v1_create_from_internal(ts, clock_seq, node));
        -:  192:}
        -:  193:
        -:  194:pg_uuid_t *
   258888:  195:uuid_v1_create_from_internal(int64 ts, int16 clock_seq, macaddr *node)
        -:  196:{
        -:  197:	pg_uuid_t  *res;
        -:  198:
   258888:  199:	res = (pg_uuid_t *) palloc(sizeof(*res));
        -:  200:
        -:  201:	/* timestamp low bytes */
   258888:  202:	res->data[0] = (uint8) ((ts & 0xff000000) >> 24);
   258888:  203:	res->data[1] = (uint8) ((ts & 0xff0000) >> 16);
   258888:  204:	res->data[2] = (uint8) ((ts & 0xff00) >> 8);
   258888:  205:	res->data[3] = (uint8) ((ts & 0xff));
        -:  206:
        -:  207:	/* timestamp mid bytes */
   258888:  208:	res->data[4] = (uint8) ((ts & 0xff0000000000) >> 40);
   258888:  209:	res->data[5] = (uint8) ((ts & 0xff00000000) >> 32);
        -:  210:
        -:  211:	/* timestamp hi bytes and version */
   258888:  212:	res->data[6] = (uint8) ((ts & 0x0f00000000000000) >> 56);
        -:  213:	/* append version to the upper MSB of timestamp hi */
   258888:  214:	res->data[6] |= (1 << 4);
   258888:  215:	res->data[7] = (uint8) ((ts & 0xff000000000000) >> 48);
        -:  216:
        -:  217:	/* clock seq hi and reserved */
   258888:  218:	res->data[8] = (uint8) ((clock_seq & 0x3f00) >> 8);
        -:  219:	/* append reserver to the clock seq high */
   258888:  220:	res->data[8] |= 0x80;
        -:  221:	/* clock seq low */
   258888:  222:	res->data[9] = (uint8) (clock_seq & 0xff);
        -:  223:
        -:  224:	/* node id */
   258888:  225:	res->data[10] = node->a;
   258888:  226:	res->data[11] = node->b;
   258888:  227:	res->data[12] = node->c;
   258888:  228:	res->data[13] = node->d;
   258888:  229:	res->data[14] = node->e;
   258888:  230:	res->data[15] = node->f;
        -:  231:
   258888:  232:	return res;
        -:  233:}
